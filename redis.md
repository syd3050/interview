### 1. Redis有几种持久化方式，有什么区别？
Redis 有4种持久化方式，分别是
1.快照方式; 2.Append-only File方式; 3.虚拟内存方式; 4.diskstore方式。
##### 1. snapshotting快照方式：将内存数据整个写入二进制文件中
首先来看配置格式：
>  *save  seconds  keys-changed*

**含义**：
在seconds秒内超过keys-changed个key被改变则将内存数据持久化到硬盘
**例如： **

save 60      1000 *#60秒内超过1000个key被改变，将内存数据持久化到硬盘*

save 300    100  *#300秒内超过1000个key被改变，将内存数据持久化到硬盘*

**原理：**
1.当前进程fork子进程用于保存快照，当前进程继续处理client请求;
2.由于os的写时复制机制，父进程和子进程共享物理页面，所有写操作均基于页面副本;
3.子进程将快照写入临时文件，写完后替换当前文件，即为新的dump.rdb文件，子进程退出。

**问题：** 如果在达到持久化的条件之前redis服务crash怎么办？所有在上次快照之后修改的数据将丢失。如果要求不能丢失，可以使用AOF的方式。

##### 2.Append-only File方式
AOF方式比快照方式更有效地持久化。每一次写操作都通过write函数追加到appendonly.aof文件中。当redis重启时将根据文件中的命令重建整个数据集。
首先来看配置格式：
> appendonly    yes            ** #启用aof持久化方式***

appendfsync always       ***#每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用***

appendfsync everysec   ***#每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐***

appendfsync no                ***#完全依赖os，性能最好,持久化没保证***

配置中的appendfsync项之所以存在，是因为对于write函数，OS会缓存数据，所以存在缓冲阶段crash导致数据丢失的可能，需要指明如何处理这一风险。
- 如果该项为no，表明完全依赖OS的刷缓存机制，存在最大的丢失风险;
- 如果该项为always，表明立即写磁盘，不依赖缓存，持久化程度最高;
- 如果该项为everysec，表明每秒写磁盘一次，是两者的折中。

##### 3.虚拟内存方式
这个方式中2.4以后弃用了，理由是：
- 保存数据太慢
- 重启太慢
- 复制太慢
- 代码太复杂

这个方式基本原理是：
当内存使用达到vm-max-memory时，开始将较老的key替换到硬盘上
- vm-max-threads=0时，主线程先阻塞client请求，同时将内存中较老的key置换到文件中并释放相应内存，直到内存降到vm-max-memory以下或者swap满或者几乎所有key都置换完成;
- vm-max-threads>0时，主线程将需要置换的key放入队列，交给工作线程处理，并继续相应client请求;

##### 4.diskstore方式
用于替代第三种虚拟内存的方式，但也不常用。
