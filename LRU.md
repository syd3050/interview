### LRU 算法及实现
LRU算法全称是Least Recently Used 最近最少使用，是一种淘汰算法，总是淘汰那些最近最少使用的数据。
**例子：**
```php
<?php 
const CAPACITY  = 2;       //容量为2，当第三个元素要进来时，需淘汰掉旧有的1个元素
$cache = new LRUCache(CAPACITY);
$cache.put(1);
$cache.put(2);
$cache.put(3);      //执行这一步前，会将元素1删除
$cache.get(2);      //访问元素2,所以它立即变得比元素3更加新了
$cache.put(4);      //这时候会淘汰元素3
```
通过上面的例子，我们了解到这个算法需要关注的几点：
- 缓存容量
- 最新访问标识
- 淘汰元素的依据

**设计A:**
假设我们用一个链表缓存所有key，凡是key被访问，无论是获取或是更新还是插入，都将其插入链表头部，淘汰时从尾部开始淘汰。其使用如下：
1. 元素A第一次访问时插入链表头部
2. 元素A第N次被访问时，从原位置删除并插入链表头部（这会A可能不在链表L头部）
3. 当要开始淘汰时，从链表末尾开始淘汰元素

这个设计最大的优点是逻辑简单，且对于存在热点数据的情况下效率较高，但对于偶发性且周期性的批量操作会导致命中率急剧下降，所以下面我们看另一个设计是否能避免这个问题。
> 为什么“偶发性或周期性的批量操作会导致命中率急剧下降”，考虑这种情况：
> 
链表大小1000，其中某些key（假设50个）在最近10s内被二次访问，但突然被批量插入990个元素，按照我们的淘汰规则，那50个key中的40个将被淘汰，但下一秒这些被淘汰的元素却很可能再次被访问，这样命中率就变低了。周期性的批量操作影响更大。


**设计B：**
假设我们用两个数据结构来实现这个算法：先进先出的链表F+链表L。其使用如下：
1. 元素A第一次访问时插入链表F
2. 元素A第二次访问时，将A移出链表F并插入链表L头部
3. 元素A被第三次访问时，将A移动到链表L头部（这会A可能不在链表L头部），同时更新访问时间
4. 当要开始淘汰时，比较链表L尾部元素LX和链表F头部元素FX的时间戳(LX_T,FX_T)，如果LX_T < FX_T 且 FX_T - LX_T >= 容忍时间T, 这时可以认为虽然链表L中尾部元素LX被访问的次数多于链表F中头部元素FX,但由于其时间太过久远（超过容忍时间T）,需要淘汰的是链表L尾部元素LX而非FX.




